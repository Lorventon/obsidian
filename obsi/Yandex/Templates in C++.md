## Вступление
Всем плюсистам привет! Могу предположить, что каждый разработчик в поисках ответов на свои вопросы на _stackoverflow_ или на _habr_, натыкался на вот такие записи:

`template <template <typename> typename C, typename T>`

Не спорю, выглядит страшно и не понятно, однако это нечто является одним из важнейшиих особенностей языка C++ и сегодня мы научимся понимать и писать его. Прошу любить и жаловать - шаблоны!

### Немного предыстории
На заре 1980-х годов в IT-индустрии начали зарождаться идеи универсального программирования. В 1979 году наш соотечественник **Александр Александрович Степанов** (человек, который в значительной степени разработал архитектуру STL) начал раздумывать над темами ролевого программирования и изучать их потенциал для революционных изменений в разработке программного обеспечения. В 1983 году в одном из древний языков программирования Ada появился стандарт ANSI с его функцией универсальных блоков. Такая идея очень понравилась Бьярну Страуструпу (создателю C++) и уже в 1988 году была представлена первая версия шаблонов в C++. После чего шаблоны стали неотъемлемой частью языка, появились различные правила и идеомы, про которые мы сегодня узнаем.

### План
Нашими задачами на сегодня будут:
- Познакомиться с терминологией и синтаксисисом
- Посмотреть правило инстанцирования (SFINAE)
- Изучить идиому CRTP
- Разобраться с проблемами использования шаблонов
- Отполировать наши знания на практических задачках
Без лишних слов, начнём!

## Терминология и синтаксис
1. **Обобщённое (универсальное) программирование** - программирования по принципу "Don't repeat yourself" (DRY) или на русскоязычную манеру - "Дублирование — это зло".

![[!Заметка 1!]]

2. **Шаблоны в C++** - обобщённое описание чего-либо, которое компилятор считывает как "правило генерации" кода. Шаблон без подстановки конкретного типа не превращается в реальный код.

![[Шутка про гномика]]

![[!Заметка 2!]]

Для понимания следующих терминов будем использовать примеры кода. Для того, чтобы не пугаться, стоит сказать, что запись шаблона состоит из 2-х ключевых слов **`template`** и **`typename`**. Итак разберем запись:

```c++
template <typename T>
T minimum(const T& a, const T& b)
{
	return a < b ? a : b;
}
```

- _template_ - ключевое слово, говорящее компилятору, что дальнейший блок кода будет шаблонным.
- _typename_ - в определениях шаблонов предоставляет указание компилятору о том, что неизвестный идентификатор является типом. Грубо говоря, чтобы нам использовать наши желаемые параметры **`a`** и **`b`**, нам нужно указать им тип, а так как наш тип неизвестен, используем **`typename`** с указанием имени типа.
- _T_ - имя нашего типа **`typename`**. Нам не обязательно называть его **`T`** (такая запись просто является внегласным правилом разработчиков), его можно назвать **`Name`** или **`CustomType`**.

![[!Заметка 3!]]

3. **Шаблонные аргументы** - это связка типа (в примере выше, это - **`typename`**) c именем типа. То есть шаблонным аргументом в вышеуказанном примере является запись **`typename T`**.
	- Стоит подметить, что C++ позволяет нам указывать шаблоны с несколькими шаблонными аргументами (`template<typename KeyType, typename ValueType>`). Ярким примером такой реализации будет словарь (известный также как ассоциативный массив или отображение). Также начиная с версии C++11 можно описывать шаблоны от произвольного количества аргументов (но это в другом уроке).
	- **Non-type template arguments** (на русский манер из [статьи](https://habr.com/ru/articles/599801/#_6_MoreArguments) "шаблонные аргументы-константы"): Шаблонный аргумент не обязан содержать ключевое слово **`typename`**, вместо него мы имеем право указать любой тип, например: `template<int T>`. Честно, на практике такая запись применяется не часто, т.к. использование шаблонов обычно подразумевает абстрактность, но имеет ряд преимуществ (их можно посмотреть в статье по ссылке выше).
	- Также укажем, что шаблонным аргументом может быть шаблон. Такую реализация вы могли увидеть в начале урока. Для укрепления материала продублируем её здесь и разберём:
	`template <template <typename> typename C, typename T>`
	Итак:
	- **`template<...>`** - ключевое слово для указания шаблона
	- **`template <typename> typename C`** - шаблонный аргумент, который тоже является шаблоном, где **`template <typename>`** - это тип, а **`typename C`** - указание имени типа.
	- **`typename T`** - уже знакомый нам шаблонный аргумент.
	Такая запись позволяет нам писать следующее **`const C<T>& value`**. То есть мы можем создать переменную value с типом "любого шаблонного класса (контейнера)". Такие записи встречаются на работе и их стоит понимать.

4. **Экземпляр шаблона** — процесс, в котором компилятор создаёт класс или функцию из шаблона. Визуальный паример можнно посмотреть в пункте 5.

5. **Шаблонная функция** - сгенерированный компилятором, в случае подстановки шаблонных аргументов в шаблон функции, реальный код функции. Для прозрачного понимая, рассмотрим картинку:

	![[Шаблонная функция.png]]

- **Явная специализация шаблонов функций**: Не стоит забывать, что шаблонные функции - это грубо говоря всё те же функции, что мы привыкли использовать. Это значит, что шаблонные функции тоже можно переопределять. То есть вот такая запись тоже имеет право на существование:
	`template<> void minimum(double a, double b);`
- **Частичная специализация шаблонов функций**: Также стоит отметить, что шаблоны функций имеют опредеоённую особеность - "предпочтение", в зависимости от передаеваемого типа. Чтобы это понять, рассмотрим код ниже:
```c++
template <class T> void f(T) {}
template <class T> void f(T*) {}
template <class T> void f(const T*) {}

int main()
{
	int i = 0;
	int *p_i = &i;
	
	const int j = 0;
	const int *p_j = &j;
	f(i); // Calls less specialized function or 'void f(T)'.
	f(p_i); // Calls more specialized function or 'void f(T*)'.
	f(p_j); // Calls even more specialized function or 'void f(const T*)'.
}
```
Итак, что же тут написано:
У нас есть 3 шаблона:
- void f(T) - для копии объекта
- void f(T*) - для указателя на объект
- void f(const T*) - для константного указателя на объект
Исходя из этого компилятор будет для "подбирать" более подходящий шаблон для конкретного типа объекта, то есть:
- для **`int i`** создастся шаблонная функция по шаблону **`template <class T> void f(T) {}`**
- для **`int *p_i`** создастся шаблонная функция по шаблону **`template <class T> void f(T*) {}
- для **`const int *p_j`** создастся шаблонная функция по шаблону **`template <class T> void f(const T*) {}`**

6. **Шаблонный класса** - шаблоны можно использовать не только для функций, но также для классов и структур. Логика и синтаксис в целом такие же, как и для функций.

## Правило SFINAE
Итак, теперь, когда мы понимаем терминологию и синтаксис, мы может перейти к правилам и идиомам.

Начнем с разбора правила SFINAE. Здесь мы расширим определения метапрограммирования, поговорим о специализации шаблонов и поймем к чему относится эта идиома. Сначала разберемся с аббревиатурой и определениями:

**SFINAE** - это аббревиатура, расшифровывающаяся как "substitution failure is not an error" или дословно на русский "сбой замены не является ошибкой".

**Метапрограммирование** - это операции, производимые во время компиляции программы, позволяющие при помощи метафункций получают типы и константы времени компиляции.

**Метафункция** - это функция, вычисляемая во время компиляции.

**Специализация (перегрузка) шаблонов** - это возможность создавать отдельные реализации функций или классов для определённых типов данных.
Она бывает 2-х типов:
- **Полная специализация** - при ней указываются значения для всех параметров шаблона. И тогда для указанного набора типов компилятор будет использовать специализацию шаблона, а не создавать шаблонный экземпляр на основе шаблона.
- **Частичная специализация** - При ней указываются значения не для всех параметров шаблона. И в этом случае будут создаваться шаблонные экземпляры.

Стало быть мы имеем раздличные определения и тепер разберемся с тем, как они связаны:
1. Когда речь заходит о SFINAE, это обязательно связано с специализацией (перегрузкой) метафункций или шаблона.
2. SFINAE - это правило, которое говорит нам о том, что мы может писать "ошибочные" (невозможные для инстанциирования из-за возникающей синтаксической ошибки) шаблоны экземпляров и при таких перегрузках компилятор может отбрасывать их, при этом продолжая работать как ни в чём не бывало, без ошибок.
 ![[!Заметка 4!]]
 Разберём пример:
```c++
struct Example { typedef int value; };

template <typename T> void func(typename T::value) {} // Определение шаблона #1
template <typename T> void func(T) {} // Определение шаблона #2

int main()
{
	func<Example>(10); // Вызов #1
	func<int>(10); // Вызов #2. Без ошибки (даже though нет для int::value) благодаря SFINAE
	return 0;
}
```
В этом примере попытка использовать тип, не являющийся классом, в квалифицированном имени **`T::value`** приводит к сбою вывода для **`func<int>`**, потому что у типа **`int`** нет вложенного типа с именем **`value`**, но программа сформирована правильно, потому что допустимая функция остаётся в наборе кандидатов функций.

![[!Заметка 5!]]

## Идиома CRTP
Без лишних слов сразу скажем:

**Идиома CRTP ("Curiously Recurring Template Pattern" или "Рекурсивный шаблон")** - это метод в C++, при котором класс наследуется от шаблона класса, используя себя в качестве параметра шаблона. Проще будет увидеть это в коде.

Для реализации CRTP будем следовать правилам:
- Начинаем с определения базового класса как шаблона, который принимает тип производного класса в качестве параметра шаблона. Это позволяет базовому классу обращаться к членам и методам производного класса.
- Производный класс должен наследоваться от базового класса-шаблона, передавая себя в качестве аргумента шаблона. Это создает _рекурсивную зависимость_, где базовый класс может использовать функциональность производного класса.
```c++
template<typename T>
class ExampleTemplate {};

class ExampleClass : public ExampleTemplate<ExampleClass> {};
```

Ура, мы реализовали идиому CRTP. Теперь нам стоит разобрать основные ошибки, чтобы правильно писать тело классов.

**Частые ошибки**:

1. _Скрытие методов:_ Если производный класс переопределяет метод базового, то методы базового класса могут стать недоступными. Решение:
- Правильно планировать имена методов
- Использовать `this->method()` для доступа к методам базового класса

2. _Неправильное наследование:_ Наследование от `Base<AnotherClass>` вместо `Base<DerivedClass>` может вызвать ошибки. Как защититься:
- Добавить приватный конструктор в базовый класс
- Сделать производный класс дружественным

![[!Заметка 6!]]

## Проблемы использования шаблонов в C++
Так, наш урок потихоньку подходит к концу, поэтому самое время разобрать проблемы использования шаблонов в C++. Сейчас посмотрим на основные и частые ошибки в реальных проектах.

1. **Ошибка 1: Сложный и менее понятный код**
	Как мы сегодня узнали, реальная разработка - это больше про чтения кода, нежели про его написание, из-за чего вот такие нетривиальные записи - `template <template <typename> typename C, typename T>` - могут вызывать трудности, увеличивающие время разработки, для разработчиков, делающих code-review. Убедительная просьба использовать шаблоны только в тех случаях, где они действительно нужны, например в задачах _стандартизации процессов_ или _масштабирования решений_.

2. **Ошибка 2: Замедление процесса компиляции и увеличение размера исполняемого файла**
	Исходя из определений шаблона и шаблонного экземпляра, компилятор для каждого нового использованного типа в шаблоне создаёт новый шаблонный экземпляр. Такой процесс безусловно увеличивает время компиляции и размер испольняемого файла. Стоит быть осторожным, особенно в больших проектах с сложными типами данных.

3. **Ошибка 3: Сложности с отладкой**
	Учитывая правило SFINAE, можно точно сказать, что использование шаблонов в C++ требует особого внимания со стороны разработчика. К сожалению, не всегда можно написать достаточно unit-тестов для проверки корректной работы шаблона. Для предотвращения таких ситуаций лучше заранее продумать, схематично изобразить или словестно описать архитектуру шаблона и возможных шаблонных экземпляров.

## Закрепление материала
Для закрепления материала предлагаю решить несколько задач с реальных собеседований в крупные IT-компании, такие как Yadro и VK Tech.

1. **Задача 1**
	Дан класс **`JsonSaver`**. Нужно написать такую реализацию, чтобы в метод **`save<...>(...)`** экземпляра класса можно было передать как и одиночный объект, так и любой контейнер (например vector или set). Достаточно написать сигнатуру функции(й).
	Пример использования данного класса:
```c++
#include <vector>

using namespace std;

class JsonSaver
{
	...
}

struct MyStruct
{
    int a{0};
    bool b{false};
    char c{'\0'};
};

int main()
{
	vector<int> vec(0, 1, 2, 3, 4);
	MyStruct str;

	JsonSaver().save<vector<int>>(vec);
	JsonSaver().save<MyStruct>(str);

	return 0;
}
```

2. **Задача 2**
	Дан следующий код:
```c++
int main() {
    std::thread* tr = new std::thread([] {
        std::cout << "Thread is running!" << std::endl;
    });
	tr->join(); // завершение потока
    
    int* pi = new int(42);
    delete(pi) // очищение памяти
    
    return 0;
}
```
Задача: нужно реализовать шаблонный класс, **`RAIIGuard`**, который бы принимал тип объекта, объект и функцию очищение памяти/завершения потока.
Пример использования такого класса:
```c++
int main() {
    std::thread* tr = new std::thread([] {
        std::cout << "Thread is running!" << std::endl;
    });
    
    RAIIGuard<std::thread> threadGuard(tr, [](std::thread* tr) {
        if (tr->joinable()) {
            tr->join();
        }
        delete tr;
    });
    
    int* pi = new int(42);
    
    RAIIGuard<int> intGuard(pi, [](int* ptr) {
        delete ptr;
    });
    
    return 0;
}
```