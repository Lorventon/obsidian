# Полиморфизм 
это одна из ключевых концепций объектно-ориентированного программирования (ООП), которая позволяет работать с объектами через общие интерфейсы, не зная их конкретных типов. В C++ полиморфизм достигается в основном через механизм виртуальных функций и динамическое приведение типов.

### Полиморфизм в C++

В C++ существует два основных типа полиморфизма:
1. **Компиляционный (или статический) полиморфизм** :
    - Реализуется через перегрузку функций и шаблоны.
    - Решение о вызове конкретной функции или метода принимается на этапе компиляции.
2. **Динамический (или запускаемый времени выполнения) полиморфизм** :
    - Реализуется через виртуальные функции и наследование.
    - Решение о вызове конкретной функции принимается во время выполнения программы.

### Динамическое приведение типов

Динамическое приведение типов используется для работы с объектами через указатели или ссылки на базовый класс. Это возможно благодаря механизму виртуальных функций.

Пример:
```C++
class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* b = new Derived();
    b->show(); // Вызовется метод Derived::show(), а не Base::show()
    delete b;
    return 0;
}
```
Здесь `b` является указателем на базовый класс `Base`, но фактически указывает на объект класса `Derived`. При вызове `b->show()` будет вызван метод `Derived::show()`, так как функция `show` объявлена как виртуальная в базовом классе.

### Таблица виртуальных функций

Механизм динамического связывания в C++ реализован с помощью таблицы виртуальных функций (Virtual Table, vtable). Каждый класс, содержащий хотя бы одну виртуальную функцию, имеет свою таблицу виртуальных функций. Эта таблица хранит указатели на все виртуальные функции, объявленные в классе и его предках.

Каждый объект класса, имеющего виртуальные функции, содержит скрытый указатель на соответствующую таблицу виртуальных функций (vptr).

#### Пример работы таблицы виртуальных функций:
```C++
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* b = new Derived();
    b->show(); // Вызовется метод Derived::show()
    delete b;
    return 0;
}
```
В данном примере:

1. Класс `Base` имеет виртуальную функцию `show`, поэтому у него есть своя таблица виртуальных функций (`vtable_Base`).
2. Класс `Derived` переопределяет эту функцию, поэтому у него тоже есть своя таблица виртуальных функций (`vtable_Derived`), где записан указатель на `Derived::show`.

Когда создается объект `Derived`, он получает указатель на свою таблицу виртуальных функций (`vptr`). Когда мы вызываем `b->show()`, программа смотрит в таблицу виртуальных функций объекта, на который указывает `b`, и вызывает соответствующую функцию.
# Memory_Model
В C++ память программы организована в несколько сегментов, каждый из которых предназначен для хранения определенного типа данных. Эти сегменты имеют свои особенности и назначение. Давайте рассмотрим основные модели памяти в C++:

### 1. Стековая память (Stack Memory)

**Описание:** Стек — это область памяти, используемая для хранения локальных переменных функций, параметров функций, адресов возврата при вызовах функций и временных данных.

**Основные характеристики:**

- **Управление:** Автоматическое управление. При входе в функцию на стек кладется новый кадр (frame), а при выходе из функции он удаляется.
- **Размер:** Обычно ограниченный размер, заданный операционной системой или компилятором (например, несколько мегабайт).
- **Скорость:** Быстрый доступ благодаря LIFO (Last In, First Out) принципу работы.
- **Пример использования:** Локальные переменные функций, параметры функций, временные объекты.
### 2. Кучная память (Heap Memory)

**Описание:** Куча — это динамическая область памяти, где можно выделять и освобождать блоки памяти вручную во время выполнения программы.

**Основные характеристики:**

- **Управление:** Ручное управление через операторы `new`/`delete` или `malloc`/`free`.
- **Размер:** Неограниченный (в пределах доступной оперативной памяти).
- **Скорость:** Медленнее, чем стек, из-за необходимости управления фрагментацией памяти и поиском свободных блоков.
- **Пример использования:** Выделение памяти для больших объектов, массивов, динамических структур данных.
### 3. Сегмент данных (Data Segment)

**Описание:** Сегмент данных используется для хранения глобальных и статических переменных, а также констант.

**Подразделы:**

- **Инициализированные данные (Initialized Data):** Хранит глобальные и статические переменные, которые были инициализированы конкретными значениями.
- **Неинициализированные данные (BSS - Block Started by Symbol):** Хранит глобальные и статические переменные, которые не были инициализированы (или инициализированы нулем).

**Основные характеристики:**

- **Управление:** Управление осуществляется компилятором и загрузчиком.
- **Размер:** Задается при компиляции и может быть изменен только при перекомпиляции.
- **Пример использования:** Глобальные и статические переменные.

### 4. Кодовый сегмент (Code Segment / Text Segment)

**Описание:** Кодовый сегмент содержит машинный код программы, который выполняется процессором.

**Основные характеристики:**

- **Управление:** Управление осуществляется компилятором и загрузчиком.
- **Размер:** Задается при компиляции и может быть изменен только при перекомпиляции.
- **Скорость:** Часто защищается от записи для обеспечения безопасности.
- **Пример использования:** Инструкции программы, исполняемые процессором.

### Дополнительные модели памяти

#### 5. Постоянная память (Constant Memory)

**Описание:** Постоянная память используется для хранения строковых литералов и других константных данных, которые не могут быть изменены программой.

**Основные характеристики:**

- **Управление:** Управление осуществляется компилятором и загрузчиком.
- **Размер:** Задается при компиляции.
- **Пример использования:** Строковые литералы, константы.

#### 6. Регистры процессора (Registers)

**Описание:** Регистры процессора — это очень быстрая, но маленькая область памяти, расположенная прямо в процессоре. Они используются для временного хранения данных и адресов, чтобы ускорить выполнение инструкций.

**Основные характеристики:**

- **Управление:** Управление полностью автоматизировано процессором.
- **Размер:** Очень маленький (обычно несколько десятков байт).
- **Скорость:** Самая высокая скорость доступа среди всех типов памяти.
- **Пример использования:** Сохранение промежуточных результатов вычислений, адресов.

### Заключение

Таким образом, в C++ существует несколько моделей памяти, каждая из которых имеет свое назначение и особенности:

- **Стековая память:** Для локальных переменных и временных данных.
- **Кучная память:** Для динамически выделяемых объектов.
- **Сегмент данных:** Для глобальных и статических переменных.
- **Кодовый сегмент:** Для машинного кода программы.
- **Постоянная память:** Для строковых литералов и констант.
- **Регистры процессора:** Для временного хранения данных внутри процессора.

# Templates
## Вступление
Всем плюсистам привет! Могу предположить, что каждый разработчик в поисках ответов на свои вопросы на _stackoverflow_ или на _habr_, натыкался на вот такие записи:

`template <template <typename> typename C, typename T>`

Не спорю, выглядит страшно и не понятно, однако это нечто является одним из важнейшиих особенностей языка C++ и сегодня мы научимся понимать и писать его. Прошу любить и жаловать - шаблоны!

### Немного предыстории
На заре 1980-х годов в IT-индустрии начали зарождаться идеи универсального программирования. В 1979 году наш соотечественник **Александр Александрович Степанов** (человек, который в значительной степени разработал архитектуру STL) начал раздумывать над темами ролевого программирования и изучать их потенциал для революционных изменений в разработке программного обеспечения. В 1983 году в одном из древний языков программирования Ada появился стандарт ANSI с его функцией универсальных блоков. Такая идея очень понравилась Бьярну Страуструпу (создателю C++) и уже в 1988 году была представлена первая версия шаблонов в C++. После чего шаблоны стали неотъемлемой частью языка, появились различные правила и идеомы, про которые мы сегодня узнаем.

### План
Нашими задачами на сегодня будут:
- Познакомиться с терминологией и синтаксисисом
- Посмотреть правило инстанцирования (SFINAE)
- Изучить идиому CRTP
- Разобраться с проблемами использования шаблонов
- Отполировать наши знания на практических задачках
Без лишних слов, начнём!

## Терминология и синтаксис
1. **Обобщённое (универсальное) программирование** - программирования по принципу "Don't repeat yourself" (DRY) или на русскоязычную манеру - "Дублирование — это зло".

![[!Заметка 1!]]

1. **Шаблоны в C++** - обобщённое описание чего-либо, которое компилятор считывает как "правило генерации" кода. Шаблон без подстановки конкретного типа не превращается в реальный код.

![[Шутка про гномика]]

![[!Заметка 2!]]

Для понимания следующих терминов будем использовать примеры кода. Для того, чтобы не пугаться, стоит сказать, что запись шаблона состоит из 2-х ключевых слов **`template`** и **`typename`**. Итак разберем запись:

```c++
template <typename T>
T minimum(const T& a, const T& b)
{
	return a < b ? a : b;
}
```

- _template_ - ключевое слово, говорящее компилятору, что дальнейший блок кода будет шаблонным.
- _typename_ - в определениях шаблонов предоставляет указание компилятору о том, что неизвестный идентификатор является типом. Грубо говоря, чтобы нам использовать наши желаемые параметры **`a`** и **`b`**, нам нужно указать им тип, а так как наш тип неизвестен, используем **`typename`** с указанием имени типа.
- _T_ - имя нашего типа **`typename`**. Нам не обязательно называть его **`T`** (такая запись просто является внегласным правилом разработчиков), его можно назвать **`Name`** или **`CustomType`**.

![[!Заметка 3!]]

1. **Шаблонные аргументы** - это связка типа (в примере выше, это - **`typename`**) c именем типа. То есть шаблонным аргументом в вышеуказанном примере является запись **`typename T`**.
	- Стоит подметить, что C++ позволяет нам указывать шаблоны с несколькими шаблонными аргументами (`template<typename KeyType, typename ValueType>`). Ярким примером такой реализации будет словарь (известный также как ассоциативный массив или отображение). Также начиная с версии C++11 можно описывать шаблоны от произвольного количества аргументов (но это в другом уроке).
	- **Non-type template arguments** (на русский манер из [статьи](https://habr.com/ru/articles/599801/#_6_MoreArguments) "шаблонные аргументы-константы"): Шаблонный аргумент не обязан содержать ключевое слово **`typename`**, вместо него мы имеем право указать любой тип, например: `template<int T>`. Честно, на практике такая запись применяется не часто, т.к. использование шаблонов обычно подразумевает абстрактность, но имеет ряд преимуществ (их можно посмотреть в статье по ссылке выше).
	- Также укажем, что шаблонным аргументом может быть шаблон. Такую реализация вы могли увидеть в начале урока. Для укрепления материала продублируем её здесь и разберём:
	`template <template <typename> typename C, typename T>`
	Итак:
	- **`template<...>`** - ключевое слово для указания шаблона
	- **`template <typename> typename C`** - шаблонный аргумент, который тоже является шаблоном, где **`template <typename>`** - это тип, а **`typename C`** - указание имени типа.
	- **`typename T`** - уже знакомый нам шаблонный аргумент.
	Такая запись позволяет нам писать следующее **`const C<T>& value`**. То есть мы можем создать переменную value с типом "любого шаблонного класса (контейнера)". Такие записи встречаются на работе и их стоит понимать.

4. **Экземпляр шаблона** — процесс, в котором компилятор создаёт класс или функцию из шаблона. Визуальный паример можнно посмотреть в пункте 5.

5. **Шаблонная функция** - сгенерированный компилятором, в случае подстановки шаблонных аргументов в шаблон функции, реальный код функции. Для прозрачного понимая, рассмотрим картинку:

	![[Шаблонная функция.png]]

- **Явная специализация шаблонов функций**: Не стоит забывать, что шаблонные функции - это грубо говоря всё те же функции, что мы привыкли использовать. Это значит, что шаблонные функции тоже можно переопределять. То есть вот такая запись тоже имеет право на существование:
	`template<> void minimum(double a, double b);`
- **Частичная специализация шаблонов функций**: Также стоит отметить, что шаблоны функций имеют опредеоённую особеность - "предпочтение", в зависимости от передаеваемого типа. Чтобы это понять, рассмотрим код ниже:
```c++
template <class T> void f(T) {}
template <class T> void f(T*) {}
template <class T> void f(const T*) {}

int main()
{
	int i = 0;
	int *p_i = &i;
	
	const int j = 0;
	const int *p_j = &j;
	f(i); // Calls less specialized function or 'void f(T)'.
	f(p_i); // Calls more specialized function or 'void f(T*)'.
	f(p_j); // Calls even more specialized function or 'void f(const T*)'.
}
```
Итак, что же тут написано:
У нас есть 3 шаблона:
- void f(T) - для копии объекта
- void f(T*) - для указателя на объект
- void f(const T*) - для константного указателя на объект
Исходя из этого компилятор будет для "подбирать" более подходящий шаблон для конкретного типа объекта, то есть:
- для **`int i`** создастся шаблонная функция по шаблону **`template <class T> void f(T) {}`**
- для **`int *p_i`** создастся шаблонная функция по шаблону **`template <class T> void f(T*) {}
- для **`const int *p_j`** создастся шаблонная функция по шаблону **`template <class T> void f(const T*) {}`**

1. **Шаблонный класса** - шаблоны можно использовать не только для функций, но также для классов и структур. Логика и синтаксис в целом такие же, как и для функций.

## Правило SFINAE
Итак, теперь, когда мы понимаем терминологию и синтаксис, мы может перейти к правилам и идиомам.

Начнем с разбора правила SFINAE. Здесь мы расширим определения метапрограммирования, поговорим о специализации шаблонов и поймем к чему относится эта идиома. Сначала разберемся с аббревиатурой и определениями:

**SFINAE** - это аббревиатура, расшифровывающаяся как "substitution failure is not an error" или дословно на русский "сбой замены не является ошибкой".

**Метапрограммирование** - это операции, производимые во время компиляции программы, позволяющие при помощи метафункций получают типы и константы времени компиляции.

**Метафункция** - это функция, вычисляемая во время компиляции.

**Специализация (перегрузка) шаблонов** - это возможность создавать отдельные реализации функций или классов для определённых типов данных.
Она бывает 2-х типов:
- **Полная специализация** - при ней указываются значения для всех параметров шаблона. И тогда для указанного набора типов компилятор будет использовать специализацию шаблона, а не создавать шаблонный экземпляр на основе шаблона.
- **Частичная специализация** - При ней указываются значения не для всех параметров шаблона. И в этом случае будут создаваться шаблонные экземпляры.

Стало быть мы имеем раздличные определения и тепер разберемся с тем, как они связаны:
1. Когда речь заходит о SFINAE, это обязательно связано с специализацией (перегрузкой) метафункций или шаблона.
2. SFINAE - это правило, которое говорит нам о том, что мы может писать "ошибочные" (невозможные для инстанциирования из-за возникающей синтаксической ошибки) шаблоны экземпляров и при таких перегрузках компилятор может отбрасывать их, при этом продолжая работать как ни в чём не бывало, без ошибок.
 ![[!Заметка 4!]]
 Разберём пример:
```c++
struct Example { typedef int value; };

template <typename T> void func(typename T::value) {} // Определение шаблона #1
template <typename T> void func(T) {} // Определение шаблона #2

int main()
{
	func<Example>(10); // Вызов #1
	func<int>(10); // Вызов #2. Без ошибки (даже though нет для int::value) благодаря SFINAE
	return 0;
}
```
В этом примере попытка использовать тип, не являющийся классом, в квалифицированном имени **`T::value`** приводит к сбою вывода для **`func<int>`**, потому что у типа **`int`** нет вложенного типа с именем **`value`**, но программа сформирована правильно, потому что допустимая функция остаётся в наборе кандидатов функций.

![[!Заметка 5!]]

## Идиома CRTP
Без лишних слов сразу скажем:

**Идиома CRTP ("Curiously Recurring Template Pattern" или "Рекурсивный шаблон")** - это метод в C++, при котором класс наследуется от шаблона класса, используя себя в качестве параметра шаблона. Проще будет увидеть это в коде.

Для реализации CRTP будем следовать правилам:
- Начинаем с определения базового класса как шаблона, который принимает тип производного класса в качестве параметра шаблона. Это позволяет базовому классу обращаться к членам и методам производного класса.
- Производный класс должен наследоваться от базового класса-шаблона, передавая себя в качестве аргумента шаблона. Это создает _рекурсивную зависимость_, где базовый класс может использовать функциональность производного класса.
```c++
template<typename T>
class ExampleTemplate {};

class ExampleClass : public ExampleTemplate<ExampleClass> {};
```

Ура, мы реализовали идиому CRTP. Теперь нам стоит разобрать основные ошибки, чтобы правильно писать тело классов.

**Частые ошибки**:

1. _Скрытие методов:_ Если производный класс переопределяет метод базового, то методы базового класса могут стать недоступными. Решение:
- Правильно планировать имена методов
- Использовать `this->method()` для доступа к методам базового класса

1. _Неправильное наследование:_ Наследование от `Base<AnotherClass>` вместо `Base<DerivedClass>` может вызвать ошибки. Как защититься:
- Добавить приватный конструктор в базовый класс
- Сделать производный класс дружественным

![[!Заметка 6!]]

## Проблемы использования шаблонов в C++
Так, наш урок потихоньку подходит к концу, поэтому самое время разобрать проблемы использования шаблонов в C++. Сейчас посмотрим на основные и частые ошибки в реальных проектах.

1. **Ошибка 1: Сложный и менее понятный код**
	Как мы сегодня узнали, реальная разработка - это больше про чтения кода, нежели про его написание, из-за чего вот такие нетривиальные записи - `template <template <typename> typename C, typename T>` - могут вызывать трудности, увеличивающие время разработки, для разработчиков, делающих code-review. Убедительная просьба использовать шаблоны только в тех случаях, где они действительно нужны, например в задачах _стандартизации процессов_ или _масштабирования решений_.

2. **Ошибка 2: Замедление процесса компиляции и увеличение размера исполняемого файла**
	Исходя из определений шаблона и шаблонного экземпляра, компилятор для каждого нового использованного типа в шаблоне создаёт новый шаблонный экземпляр. Такой процесс безусловно увеличивает время компиляции и размер испольняемого файла. Стоит быть осторожным, особенно в больших проектах с сложными типами данных.

3. **Ошибка 3: Сложности с отладкой**
	Учитывая правило SFINAE, можно точно сказать, что использование шаблонов в C++ требует особого внимания со стороны разработчика. К сожалению, не всегда можно написать достаточно unit-тестов для проверки корректной работы шаблона. Для предотвращения таких ситуаций лучше заранее продумать, схематично изобразить или словестно описать архитектуру шаблона и возможных шаблонных экземпляров.

## Закрепление материала
Для закрепления материала предлагаю решить несколько задач с реальных собеседований в крупные IT-компании, такие как Yadro и VK Tech.

1. **Задача 1**
	Дан класс **`JsonSaver`**. Нужно написать такую реализацию, чтобы в метод **`save<...>(...)`** экземпляра класса можно было передать как и одиночный объект, так и любой контейнер (например vector или set). Достаточно написать сигнатуру функции(й).
	Пример использования данного класса:
```c++
#include <vector>

using namespace std;

class JsonSaver
{
	...
}

struct MyStruct
{
    int a{0};
    bool b{false};
    char c{'\0'};
};

int main()
{
	vector<int> vec(0, 1, 2, 3, 4);
	MyStruct str;

	JsonSaver().save<vector<int>>(vec);
	JsonSaver().save<MyStruct>(str);

	return 0;
}
```

1. **Задача 2**
	Дан следующий код:
```c++
int main() {
    std::thread* tr = new std::thread([] {
        std::cout << "Thread is running!" << std::endl;
    });
	tr->join(); // завершение потока
    
    int* pi = new int(42);
    delete(pi) // очищение памяти
    
    return 0;
}
```
Задача: нужно реализовать шаблонный класс, **`RAIIGuard`**, который бы принимал тип объекта, объект и функцию очищение памяти/завершения потока.
Пример использования такого класса:
```c++
int main() {
    std::thread* tr = new std::thread([] {
        std::cout << "Thread is running!" << std::endl;
    });
    
    RAIIGuard<std::thread> threadGuard(tr, [](std::thread* tr) {
        if (tr->joinable()) {
            tr->join();
        }
        delete tr;
    });
    
    int* pi = new int(42);
    
    RAIIGuard<int> intGuard(pi, [](int* ptr) {
        delete ptr;
    });
    
    return 0;
}
```

