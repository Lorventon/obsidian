## **Вступление**
Приветствую всех читающих, наверняка вы не раз слышали о такой штуке, как абстрактные классы, виртуальные функции, таблицы виртуальных функций и указатели на них, перегрузки операторов и шаблоны. 

Сегодня мы поговорим об этом, узнаем, как устроен полиморфизм в C++  *под капотом*, как с помощью него можно хранить указатели на объекты разных классов в одной коллекции и ответим на **коварный вопрос**, который встречается в собеседованиях на позицию C++ разработчика по этой теме.

## **План**
### [[Polymorphism in C++#1. **Введение**| 1. Введение]]
- [[Polymorphism in C++#**1.1 Что такое полиморфизм**| 1.1 Что такое полиморфизм]]
---
### [[Polymorphism in C++#**2. Что такое статический полиморфизм?**| 2. Статический полиморфизм]]
- [[Polymorphism in C++#**2.1 Определение**| 2.1 Определение]]
- [[Polymorphism in C++#**2.2 Перегрузка функций**| 2.2 Перегрузка функций]]
- [[Polymorphism in C++#**2.3 Шаблоны (templates)**| 2.3 Шаблоны]]
- [[Polymorphism in C++#**2.4 Перегрузка операторов**| 2.4 Перегрузка операторов]]
---
### [[Polymorphism in C++#**3. Что такое динамический полиморфизм?**| 3. Динамический полиморфизм]]
- [[Polymorphism in C++#**3.1 Определение**| 3.1 Что такое динамический полиморфизм?]]
- [[Polymorphism in C++#**3.2 Наследование и виртуальные функции**| 3.2 Наследование и виртуальные функции:]]
    - [[Polymorphism in C++#**3.2.1 Пример базового класса и производного класса**| 3.2.1 Пример базового и производного класса]]
    - [[Polymorphism in C++#**3.2.2 Ключевое слово `virtual` и `override`**| 3.2.2 Ключевое слово virtual и override]]
    - [[Polymorphism in C++#**3.2.3 Таблица виртуальных функций `vtable`, указатель `vptr`**| 3.2.3 Таблица виртуальных функций vtable, указатель vptr]]
    - [[Polymorphism in C++#**3.2.4 Как это работает?**| 3.2.4 Как это работает?]]
- [[Polymorphism in C++#**3.3 Абстрактные классы и чисто виртуальные функции**| 3.3 Абстрактные классы и чисто виртуальные функции: ]]
    - [[Polymorphism in C++#**3.3 Абстрактные классы и чисто виртуальные функции**| 3.3.1 Что такое абстрактный класс]]
    - [[Polymorphism in C++#**3.3.2 Пример использования чисто виртуальных функций**| 3.3.2 Пример использования чисто виртуальных функций]]
    - [[Polymorphism in C++#**3.3.3 Важность виртуального деструктора**| 3.3.3 Важность виртуального деструктора]]
- [[Polymorphism in C++#**3.4 Позднее и раннее связывание**| 3.4 Позднее и раннее связывание]]
- [[Polymorphism in C++#**3.5 CRTP**| 3.5 CRTP]]
---
### [[Polymorphism in C++#**4. Сравнение статического и динамического полиморфизма**| 4. Сравнение статического и динамического полиморфизма]]
- [[Polymorphism in C++#**4.1 Производительность**| 4.1 Производительность]]
- [[Polymorphism in C++#**4.2 Гибкость**| 4.2 Гибкость]]
- [[Polymorphism in C++#**4.3 Удобство использования**| 4.3 Удобство использования]]
---
### [[Polymorphism in C++#**5. Задачи и вопросы**| 5. Задачи и вопросы]]
---
## **1. Введение**
### **1.1 Что такое полиморфизм**
**Полиморфизм** — это одна из ключевых концепций объектно-ориентированного программирования, которая позволяет объектам разных типов обрабатываться через **единый интерфейс**. Само слово "полиморфизм" происходит от греческих слов "поли" (много) и "морф" (форма), что буквально означает **"много форм"**. 

Например, представьте, что у вас есть функция `draw()`, которая рисует фигуры. Благодаря полиморфизму, эта функция может работать с **кругами и квадратами**, даже если они реализованы как разные классы. Вместо того чтобы писать отдельную функцию для каждого типа фигуры, вы можете использовать единый интерфейс.
Здесь нет ничего сложного, функция `draw()` существует, как в классе **Circle**, так и в классе **Square**, посмотрим на небольшой пример кода

``` C++
#include "iostream"  
  
class Shape {  
public:  
    virtual void draw() = 0; // Чисто виртуальная функция, делающая Shape абстрактным классом  
    virtual ~Shape() {std::cout << "~Shape()\n"; }; // Виртуальный деструктор  
};  
  
class Circle : public Shape {  
public:  
    Circle() {std::cout << "Circle()\n"; }  
  
    void draw() override{  
        std::cout << "Draw Circle\n";  
    }  
};  
  
class Square : public Shape {  
public:  
    Square() {std::cout << "Square()\n";}  
  
    void draw() override{  
        std::cout << "Draw Square\n";  
    }  
};  
  
int main () {  
  
    Shape* shape1 = new Circle();  
    Shape* shape2 = new Square();  
  
    shape1->draw(); // Выведет: Draw Circle  
    shape2->draw(); // Выведет: Draw Square  
  
    delete shape1;  
    delete shape2;  
  
    return 0;  
}
```
Как вы могли заметить в функции *main()* создаются указатели на базовый класс Shape, но в первом случае память выделяется для объекта **Circle()**, а во второму случае для объекта **Square()**.

По итогу мы имеем два указателя, у которых один и тот же тип `Shape*`, но посмотрите, что будет, если мы вызовем у них функцию **draw()**. Да, вызовутся соответствующие функции класса **Circle** для **`shape1`** и класса Square для **`shape2`**

Это называется ***динамическим полиморфизмом*** - по истине удивительная вещь в C++, которая делает код масштабируемым и расширяемым. Также внимательный читатель заметил, что в классе `Shape` существует загадочная виртуальная функция, равная нулю, а также виртуальный деструктор. Но не будем спешить, ещё успеем освятить эти темы, когда будем говорить о динамическом полиморфизме, пока поговорим о его младшем брате - ***статическом полиморфизме***.
## **2. Что такое статический полиморфизм?**

### **2.1 Определение** 
Статический полиморфизм — это механизм, при котором выбор нужной функции или метода происходит на этапе **компиляции**. В отличие от динамического полиморфизма, где решение принимается во время выполнения программы, статический полиморфизм позволяет компилятору заранее определить, какой код будет вызван. Это делает программы более эффективными, так как исключаются накладные расходы на динамическое связывание.

В C++ статический полиморфизм реализуется с помощью:
1. **Перегрузки функций (function overloading)**.
2. **Шаблонов (templates)**.
3. **Перегрузки операторов (operator overloading)**.
Рассмотрим каждый из этих механизмов подробнее.
---
### **2.2 Перегрузка функций**
Перегрузка функций позволяет создавать несколько функций с разными ***`сигнатурами`***, но одинаковыми именами. Компилятор выбирает подходящую функцию на основе типов аргументов, переданных при вызове.

***`Сигнатура функции`*** - это тип возвращаемого значения и типы параметров функции!
#### Пример:

```C++
#include <iostream>

void print(int value) {
    std::cout << "Integer: " << value << std::endl;
}

void print(double value) {
    std::cout << "Double: " << value << std::endl;
}

void print(const std::string& value) {
    std::cout << "String: " << value << std::endl;
}

int main() {
    print(42);           // Вызов print(int)
    print(3.14);         // Вызов print(double)
    print("Hello");      // Вызов print(const std::string&)
    return 0;
}
```

Вывод
```
Integer: 42
Double: 3.14
String: Hello
```
#### Объяснение:
- Компилятор выбирает нужную версию функции `print` на основе типа аргумента.
- Это пример статического полиморфизма, так как решение принимается на этапе компиляции.
---
### **2.3 Шаблоны (templates)**

Шаблоны позволяют создавать обобщенные функции и классы, которые могут работать с разными типами данных. Компилятор генерирует конкретные реализации шаблонов для каждого используемого типа. 

Если вы ещё не знакомы с шаблонами, то можете более подробно узнать про них в другой нашей статье.
#### Пример:
``` C++
#include <iostream>

template <typename T>
void print(T value) {
    std::cout << "Value: " << value << std::endl;
}

int main() {
    print(42);           // Вызов print<int>(int)
    print(3.14);         // Вызов print<double>(double)
    print("Hello");      // Вызов print<const char*>(const char*)
    return 0;
}
```

Вывод
```
Value: 42
Value: 3.14
Value: Hello
```
#### Объяснение:

- Шаблонная функция `print` может работать с любым типом данных.
- Компилятор автоматически генерирует реализации для `int`, `double` и `const char*`.
---
### **2.4 Перегрузка операторов**

Перегрузка операторов позволяет определять поведение операторов (например, `+`, `-`, `<<`) для пользовательских типов данных. Это также пример статического полиморфизма, так как компилятор выбирает нужную реализацию оператора на этапе компиляции.
#### Пример:
``` C++
#include <iostream>

class Vector {
public:
    int x, y;

    Vector(int x, int y) : x(x), y(y) {}

    // Перегрузка оператора +
    Vector operator+(const Vector& other) const {
        return Vector(x + other.x, y + other.y);
    }
};

int main() {
    Vector v1(1, 2);
    Vector v2(3, 4);
    Vector v3 = v1 + v2; // Использование перегруженного оператора +

    std::cout << "v3: (" << v3.x << ", " << v3.y << ")" << std::endl;
    return 0;
}
```

Вывод
```
v3: (4, 6)
```
#### Объяснение:
- Оператор `+` перегружен для класса `Vector`.
- Компилятор выбирает эту реализацию оператора на этапе компиляции.


## **3. Что такое динамический полиморфизм?**
### **3.1 Определение**

`Динамический полиморфизм` — это механизм, при котором выбор нужной функции или метода происходит **во время выполнения программы**. Это позволяет объектам разных типов обрабатываться через единый интерфейс, даже если конкретный тип объекта неизвестен на этапе компиляции. В C++ динамический полиморфизм реализуется с помощью **виртуальных функций** и **наследования**.

### **3.2 Наследование и виртуальные функции**

#### **3.2.1 Пример базового класса и производного класса**

Рассмотрим пример, где у нас есть базовый класс `Shape` и несколько производных классов  Каждый из этих классов реализует метод `draw()`, но по-своему. 

``` C++
#include <iostream>  
#include <memory>  
#include <vector>  
  
class Shape {  
public:  
    virtual void draw() const {  
        std::cout << "Drawing a shape\n";  
    }  
  
    virtual ~Shape() = default; // Виртуальный деструктор  
};  
  
class Circle : public Shape {  
public:  
    void draw() const override {  
        std::cout << "Drawing a circle\n";  
    }  
};  
  
class Square : public Shape {  
public:  
    void draw() const override {  
        std::cout << "Drawing a square\n";  
    }  
};  
  
class Rectangle : public Shape{  
public:  
    void draw() const override {  
        std::cout << "Drawing a rectangle\n";  
    }  
};  
  
class Triangle : public Shape{  
public:  
    void draw() const override {  
        std::cout << "Drawing a triangle\n";  
    }  
};
```
Теперь напишем функцию main() следующим образом и посмотрим, что произойдёт.
```C++
int main() {  
    std::shared_ptr<Shape> shape_1 = std::make_shared<Circle>();  
    std::shared_ptr<Shape> shape_2 = std::make_shared<Square>();  
    std::shared_ptr<Shape> shape_3 = std::make_shared<Rectangle>();  
    std::shared_ptr<Shape> shape_4 = std::make_shared<Triangle>();  
      
    std::vector< std::shared_ptr<Shape> > collection {shape_1, shape_2, shape_3, shape_4};  
  
    for (const auto& it : collection)  
    {  
        it->draw();  
    }  
  
    return 0;  
}
```

При запуске программы в консоли вы увидите следующее

``` bash
Drawing a circle
Drawing a square
Drawing a rectangle
Drawing a triangle
```

``` md
Мы храним в std::vector объекты типа std::shared_ptr<Shape>, но фактически каждый из этих объектов указывает на разные объекты. Благодаря полиморфизму у нас есть возможность работать с разными дочерними объектами через единый интерфейс (базовый класс).
```

***Подробно:***

У нас есть четыре объекта : **shape_1, shape_2, shape_3, shape_4**

Они все одного типа, поэтому мы можем их хранить в одной коллекции, но гибкость и масштабируемость проявляется тогда, когда мы начинаем работать с каждым из этих объектов через единый цикл for. У нас есть возможность вызывать методы производных классов через указатель на базовый класс.

На консоль выводятся соответствующие результаты вызовов, компилятор понимает, какой метод вызывать благодаря **`таблице виртуальных функций/методов`**
#### **3.2.2 Ключевое слово `virtual` и `override`**
Ключевое слово `virtual` указывает, что функция может быть переопределена в производных классах. 

Ключевое слово `override` используется для переопределения функции в производных классах (мы можем поменять реализацию). Смотрите пример выше, функция draw() переопределена в классах наследниках `Circle` и `Square` и так далее, у них разная реализация.

#### **3.2.3 Таблица виртуальных функций `vtable`, указатель `vptr`**

Когда компилятор встречает виртуальную функцию, он создает **таблицу виртуальных функций (vtable)** для каждого класса, содержащего виртуальные методы. Эта таблица содержит `указатели` на реализацию виртуальных функций для каждого класса. При вызове виртуальной функции через указатель на базовый класс, программа использует **vtable** для определения, какую реализацию функции вызвать на этапе выполнения программы.

Если класс **Derived** не имеет виртуальных функций, но унаследован от класса Base, у которого они есть, то при создании объекта класса Derived таблица виртуальных функций будет такой же, как у класса Base.

#### **3.2.4 Как это работает?**
1. **Создание vtable**:
    - Для каждого класса, содержащего виртуальные функции, компилятор создает отдельную vtable.
    - В таблице хранятся указатели на реализацию виртуальных функций для этого класса.
2. **Указатель vptr**:
    - Каждый объект класса, содержащего виртуальные функции, имеет скрытый указатель `vptr`, который указывает на vtable своего класса.
    - Этот указатель автоматически инициализируется при создании объекта.
    - Объект не содержит таблицу, он содержит всего лишь указатель на эту таблицу!
3. **Вызов виртуальной функции**:
    - Когда вызывается виртуальная функция через указатель или ссылку на базовый класс, программа использует `vptr` для поиска нужной функции в vtable.
    - Это позволяет вызывать правильную реализацию функции, даже если тип объекта известен только во время выполнения.

### **3.3 Абстрактные классы и чисто виртуальные функции**

#### **3.3.1 Что такое абстрактный класс?**

`Абстрактный класс` — это класс, который содержит хотя бы одну **чисто виртуальную функцию**. Такой класс не может быть создан напрямую, но может использоваться как **`интерфейс`** для производных классов.

#### **3.3.2 Пример использования чисто виртуальных функций**

Чисто виртуальная функция объявляется с помощью синтаксиса `virtual void func() = 0;`. Это означает, что функция не имеет реализации в базовом классе и должна быть переопределена в производных классах.

``` C++
class Shape {
public:
    virtual void draw() const = 0; // Чисто виртуальная функция
    virtual ~Shape() = default;    // Виртуальный деструктор
};

class Circle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing a circle\n";
    }
};

class Square : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing a square\n";
    }
};
```
В этом примере `Shape` — это абстрактный класс, а `Circle` и `Square` — конкретные классы, реализующие метод `draw()` по-своему.

#### **3.3.3 Важность виртуального деструктора**

Если вы работаете с указателями или ссылкам на базовый класс, которые используют классы наследники, то деструктор в базовом классе **`стоит делать виртуальным`**, а также это необходимо и для интерфейсов (абстрактных классов).

##### **Проблема без виртуального деструктора**

Предположим, у вас есть иерархия классов:
``` C++
class Base {
public:
    ~Base() {
        // Деструктор базового класса
    }
};

class Derived : public Base {
public:
    ~Derived() {
        // Деструктор производного класса
    }
};
```

Если вы создадите объект производного класса и удалите его через указатель на базовый класс:
``` C++
Base* ptr = new Derived();
delete ptr;
```
то будет вызван только деструктор базового класса `Base`, а деструктор производного класса `Derived` не будет вызван. Это приведет к утечке ресурсов, если производный класс выделял память или владел другими ресурсами.

##### **Решение: виртуальный деструктор**
``` C++
class Base {
public:
    virtual ~Base() {
        // Виртуальный деструктор базового класса
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // Деструктор производного класса
    }
};
```

Теперь, если вы удалите объект через указатель на базовый класс:
```
Base* ptr = new Derived();
delete ptr;
```

компилятор вызовет деструктор производного класса `Derived`, а затем деструктор базового класса `Base`. Это гарантирует корректное освобождение всех ресурсов.

##### **Почему это важно при динамическом полиморфизме**

Динамический полиморфизм предполагает использование указателей или ссылок на базовый класс для работы с объектами производных классов. Если деструктор базового класса не виртуальный, то при удалении объекта через указатель на базовый класс может произойти утечка ресурсов или неопределенное поведение, так как деструктор производного класса не будет вызван.

### **3.4 Позднее и раннее связывание**

Стоит сказать, что динамический полиморфизм зачастую называют `поздним связыванием`, а статический - `ранним связыванием`.

Напомню, что для `позднего связывания` компилятор делает выбор того, какую функцию/метод выбрать во время выполнения программы, а для `раннего связывания` во время компиляции. 

### **3.5 CRTP**
Идиома статического полиморфизма в C++ называется **Curiously Recurring Template Pattern** (CRTP). Этот паттерн позволяет осуществлять `полиморфизм` во время компиляции, а не во время выполнения, как это происходит с использованием виртуальных функций. `CRTP` используется для реализации функций, которые **могут быть переопределены** в производных классах, **без использования виртуальных функций**, что позволяет избежать их накладных расходов и добиться большей производительности.

#### **Как работает CRTP?**

**CRTP** заключается в том, что базовый класс является шаблоном, параметризированным производным классом. Производный класс передает себя как параметр шаблона базовому классу.

Пример использования CRTP: 
```C++
#include <iostream>

// Базовый шаблонный класс, параметризированный производным классом
template <typename Derived>
class Base {
public:
    void interface() {
        // Вызов метода реализации из производного класса
        static_cast<Derived*>(this)->implementation();
    }

    // Метод реализации по умолчанию
    void implementation() {
        std::cout << "Base implementation" << std::endl;
    }
};

// Производный класс, передающий себя как параметр базовому классу
class Derived : public Base<Derived> {
public:
    // Переопределение метода реализации
    void implementation() {
        std::cout << "Derived implementation" << std::endl;
    }
};

int main() {
    Derived d;
    d.interface(); // Вызывает Derived::implementation
    return 0;
}

```

#### **Особенности и преимущества CRTP**

##### *Полиморфизм во время компиляции:*

 CRTP позволяет производному классу переопределять функции базового класса без использования виртуальных функций. Это означает, что вызовы функций разрешаются на этапе компиляции, что устраняет накладные расходы, связанные с виртуальными вызовами.

##### *Гибкость и расширяемость:*

 CRTP предоставляет возможность реализации функций, которые могут быть переопределены в производных классах, сохраняя при этом статическую типизацию.

##### *Использование в шаблонных библиотеках:*

 CRTP широко используется в шаблонных библиотеках, таких как STL и Boost, для реализации эффективного и гибкого кода.

##### *Применение CRTP*

CRTP можно применять в различных сценариях, таких как:
**Реализация интерфейсов:**
 CRTP позволяет создать шаблонный интерфейс, который может быть реализован в производных классах. 
 
```C++
    template <typename Derived>
    class Interface {
    public:
        void execute() {
            static_cast<Derived*>(this)->execute_impl();
        }
    };

    class Implementation : public Interface<Implementation> {
    public:
        void execute_impl() {
            std::cout << "Executing implementation" << std::endl;
        }
    };
    

```

## **4. Сравнение статического и динамического полиморфизма**

### **4.1 Производительность**

- **Когда статический полиморфизм быстрее**:  
    Статический полиморфизм, реализуемый через шаблоны или перегрузку функций, не требует дополнительных затрат на этапе выполнения. Компилятор разрешает вызовы методов на этапе компиляции, что делает код более эффективным.
- **Накладные расходы динамического полиморфизма (vtable)**:  
    Динамический полиморфизм, основанный на механизме виртуальных функций, требует использования таблицы виртуальных методов. Это добавляет накладные расходы на этапе выполнения, так как каждый вызов виртуальной функции требует дополнительного обращения к памяти для поиска нужного метода в vtable. Это может замедлить выполнение программы, особенно в системах с ограниченными ресурсами.

### **4.2 Гибкость**

- **Когда статический полиморфизм более гибкий**:  
    Статический полиморфизм позволяет создавать универсальные шаблоны, которые могут работать с различными типами данных без потери производительности. Это особенно полезно в библиотеках, где требуется высокая степень абстракции и повторного использования кода. Например, шаблоны в C++ позволяют писать обобщённые алгоритмы, которые могут быть применены к любым типам данных.
- **Когда динамический полиморфизм незаменим**:  
    Динамический полиморфизм необходим в случаях, когда типы объектов неизвестны на этапе компиляции и определяются только во время выполнения программы. Например, в системах с плагинами или в приложениях, где требуется динамическое изменение поведения объектов. Динамический полиморфизм также упрощает расширение кода, так как новые классы могут быть добавлены без изменения существующего кода.

### **4.3 Удобство использования**

- **Примеры, когда лучше использовать статический полиморфизм**:  
    Статический полиморфизм идеально подходит для задач, где типы данных известны на этапе компиляции и требуется максимальная производительность. Например, в математических библиотеках, где операции должны выполняться быстро и без накладных расходов. Также статический полиморфизм удобен для реализации контейнеров и алгоритмов, таких как стандартная библиотека шаблонов (STL) в C++.
- **Примеры, когда лучше использовать динамический полиморфизм**:  
    Динамический полиморфизм стоит использовать в случаях, когда требуется гибкость и расширяемость. Например, в графических интерфейсах пользователя (GUI), где элементы управления могут быть добавлены или изменены во время выполнения. Также динамический полиморфизм полезен в системах, где требуется работа с объектами, тип которых определяется только в runtime, например, в играх или симуляторах.

Если вы уже забыли разницу, то данная картинка легко вам о ней напомнит.
![[Pasted image 20250307132912.png]]

## **5. Задачи и вопросы**
### **Первая задача**

Посмотрите на блок кода и ответьте на вопросы после.
``` C++
#include "iostream"  
  
struct A{ };  
  
struct B : public A {  
    void virtual foo() { }  
};  
  
  
int main() {  
    A obj_a;  
    B obj_b;  
  
    std::cout << sizeof(obj_a) << std::endl;  
    std::cout << sizeof(obj_b) << std::endl;  
      
    return 0;  
}
```

1. **Что выведется на экран?**
<details>
<summary>Нажмите, чтобы увидеть ответ</summary>
1 <br>
8
</details>
2. **Почему вывелось именно это?**
<details>
<summary>Нажмите, чтобы увидеть ответ</summary>
В первом случае структура obj_a весит 1 байт, т.к классы и структуры (даже, если пустые) должны сколько-то весить и занимать место в памяти. Собственно, здесь нет ничего сложного, всё предельно очевидно <br> 
<br>
Во втором случае obj_b весит целых 8 байтов, кто-то может подумать, что столько весит виртуальная функций foo(), но это не так. <br>
<br>
Всё дело в том, что при создании виртуальной функции мы говорим компилятору, чтобы он также создал и таблицу виртуальных функций для этой структуры, а как мы помним, чтобы получать доступ к данной таблице необходим указатель, который храниться в этой же самой структуре, он-то и весит 8 байтов.
</details>

### **Вторая задача**

Будет небольшой список вопросов, постарайтесь ответить на них своими словами, после вопроса будет приведено краткое объяснение. (Возможно несколько вариантов для лучшего понимания)

#### Что такое **полиморфизм**?

1.Возможность объектов вести себя по-разному, используя при этом общий интерфейс  
Пример: метод `draw()` у класса `Square` и у класса `Circle` будет вести себя по-разному.  
  
2.Механизм, который реализован посредством наследования и виртуальных функций.  
Позволяет создавать указатели или ссылки на базовый класс, при этом осуществляя работу с объектами классов наследников.  
  
3.Полиморфизм — важная концепция объектно-ориентированного программирования, которая позволяет объектам производных классов быть обработанными через указатели или ссылки на базовый класс. Это достигается с помощью виртуальных функций, которые определяются в базовом классе и могут быть переопределены в производных классах.

#### Как работает vtable и vptr?
##### vtable (виртуальная таблица)

Это таблица указателей на виртуальные функции класса. Каждый класс, содержащий виртуальные функции, имеет свою собственную vtable. В vtable хранятся адреса функций, которые должны быть вызваны для объектов данного класса. 

##### vptr (указатель на vtable)

Это скрытый указатель в каждом объекте класса, содержащего виртуальные функции. Он указывает на vtable соответствующего класса. Когда объект создается, vptr инициализируется, указывая на vtable его класса.


``` C++
#include <iostream>

class Base {
public:
    virtual void display() const {
        std::cout << "Display from Base" << std::endl;
    }
    virtual void show() const {
        std::cout << "Show from Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() const override {
        std::cout << "Display from Derived" << std::endl;
    }
};

int main() {
    Base* b = new Derived();
    b->display(); // Вызовет Derived::display() благодаря vtable
    b->show();    // Вызовет Base::show() поскольку она не переопределена

    delete b;
    return 0;
}

```

#### В чём проблема?
``` C++
#include <iostream>

class Base {
public:
    Base() { std::cout << "Base constructor\n"; }
    ~Base() { std::cout << "Base destructor\n"; }  
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived constructor\n"; }
    ~Derived() { std::cout << "Derived destructor\n"; }
};

int main() {
    Base* ptr = new Derived(); 
    delete ptr;  
    return 0;
}
```

<details>
<summary>Нажмите, чтобы увидеть ответ</summary>
Отсутствует виртуальный деструктор в базовом классе, из-за чего не вызывается деструктор класса Derived. Поэтому происходит утечка памяти.
</details>

#### Как называется идиома статического полиморфизма в C++? 

Идиома статического полиморфизма в C++ называется Curiously Recurring Template Pattern (CRTP). Она позволяет реализовывать полиморфизм во время компиляции, передавая производный класс как параметр шаблона базовому классу. Это обеспечивает вызовы функций без накладных расходов, связанных с виртуальными функциями, и широко используется для создания гибкого и эффективного кода.