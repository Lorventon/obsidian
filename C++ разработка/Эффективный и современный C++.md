- [x] Введение ✅ 2025-02-11
- [x] Глава 1. Вывод типов ✅ 2025-02-11
  - [x] 1.1. Вывод типа шаблона ✅ 2025-02-11
  - [x] 1.2. Вывод типа auto ✅ 2025-02-11
  - [x] 1.3. Знакомство с decltype ✅ 2025-02-11
  - [x] 1.4. Как просмотреть выведенные типы ✅ 2025-02-11
- [x] Глава 2. Объявление auto ✅ 2025-02-11
  - [x] 2.1. Предпочитайте auto явному объявлению типа ✅ 2025-02-11
  - [x] 2.2. Если auto выводит нежелательный тип, используйте явно типизированный инициализатор ✅ 2025-02-11
- [ ] Глава 3. Переход к современному С++
  - [x] 3.1. Различие между `{}` и `()` при создании объектов ✅ 2025-02-11
  - [x] 3.2. Предпочитайте `nullptr` значениям `0` и `NULL` ✅ 2025-02-11
  - [x] 3.3. Предпочитайте объявление псевдонимов применению `typedef` ✅ 2025-02-11
  - [ ] 3.4. Предпочитайте перечисления с областью видимости перечислениям без таковой
  - [ ] 3.5. Предпочитайте удаленные функции закрытым неопределенным
  - [ ] 3.6. Объявляйте перекрывающие функции как `override`
  - [ ] 3.7. Предпочитайте итераторы `const_iterator` итераторам `iterator`
  - [ ] 3.8. Если функции не генерируют исключений, объявляйте их как `noexcept`
  - [ ] 3.9. Используйте `constexpr`, где это возможно
  - [ ] 3.10. Делайте константные функции-члены безопасными в смысле потоков
  - [ ] 3.11. Генерация специальных функций-членов
- [ ] Глава 4. Интеллектуальные указатели
  - [ ] 4.1. Используйте `std::unique_ptr` для управления ресурсами путем исключительного владения
  - [ ] 4.2. Используйте `std::shared_ptr` для управления ресурсами путем совместного владения
  - [ ] 4.3. Используйте `std::weak_ptr` для `std::shared_ptr`-подобных указателей, которые могут быть висячими
  - [ ] 4.4. Предпочитайте использование `std::make_unique` и `std::make_shared` оператору `new`
  - [ ] 4.5. При использовании идиомы указателя на реализацию определяйте специальные функции-члены в файле реализации
- [ ] Глава 5. Rvalue-ссылки, семантика перемещений и прямая передача
  - [ ] 5.1. Азы `std::move` и `std::forward`
  - [ ] 5.2. Отличие универсальных ссылок от rvalue-ссылок
  - [ ] 5.3. Используйте `std::move` для rvalue-ссылок, а `std::forward` для универсальных ссылок
  - [ ] 5.4. Избегайте перегрузок для универсальных ссылок
  - [ ] 5.5. Знакомство с альтернативами перегрузки для универсальных ссылок
  - [ ] 5.6. Свертывание ссылок
  - [ ] 5.7. Считайте, что перемещающие операции отсутствуют, дороги или не используются
  - [ ] 5.8. Познакомьтесь со случаями некорректной работы прямой передачи
- [ ] Глава 6. Лямбда-выражения
  - [ ] 6.1. Избегайте режимов захвата по умолчанию
  - [ ] 6.2. Используйте инициализирующий захват для перемещения объектов в замыкания
  - [ ] 6.3. Используйте параметры `decltype` для `auto&&` для передачи с помощью `std::forward`
  - [ ] 6.4. Предпочитайте лямбда-выражения `std::bind`
- [ ] Глава 7. Параллельные вычисления
  - [ ] 7.1. Предпочитайте программирование на основе задач программированию на основе потоков
  - [ ] 7.2. Если важна асинхронность, указывайте `std::launch::async`
  - [ ] 7.3. Делайте `std::thread` неподключаемым на всех путях выполнения
  - [ ] 7.4. Помните о разном поведении деструкторов дескрипторов потоков
  - [ ] 7.5. Применяйте фьючерсы `void` для одноразовых сообщений о событиях
  - [ ] 7.6. Используйте `std::atomic` для параллельности, `volatile` – для особой памяти
- [ ] Глава 8. Тонкости
  - [ ] 8.1. Рассмотрите передачу по значению для копируемых параметров, которые легко перемещаются и всегда копируются
  - [ ] 8.2. Рассмотрите применение размещения вместо вставки
- [ ] Предметный указатель
